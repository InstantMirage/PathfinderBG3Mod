local __util = require 'larian.util'
--Conditions for Baldur's Path

-- Status: Movement (todo: refactor movement statuses to use these)

--Returns if it is currently possible to Stride, if not, movement will be cleared
function AutoStride()
	local hasActions = HasActionResource('ActionPoint', 1 , 0, false, false) or HasStatus('HASTE_ATTACK')
	local automaticStride = ~HasStatus('MANUAL_STRIDE')
	
	return ~Immobilized() & hasActions & automaticStride
end

-- Can~Step into Difficult Terrain
function DifficultTerrainStatusID()
	return StatusId('DIFFICULT_TERRAIN') | StatusId('DIFFICULT_TERRAIN_DEEPWATER') | StatusId('DIFFICULT_TERRAIN_MUD') | StatusId('DIFFICULT_TERRAIN_VINES') | StatusId('DIFFICULT_TERRAIN_OVERGROWTH') | StatusId('DIFFICULT_TERRAIN_WEB') | StatusId('MAG_RAMPART_AURA_DIFFICULT_TERRAIN') | StatusId('DIFFICULT_TERRAIN_LAVA')
end

function HasDifficultTerrainStatus()
	return HasStatus('DIFFICULT_TERRAIN') | HasStatus('DIFFICULT_TERRAIN_DEEPWATER') | HasStatus('DIFFICULT_TERRAIN_MUD') | HasStatus('DIFFICULT_TERRAIN_VINES') | HasStatus('DIFFICULT_TERRAIN_OVERGROWTH') | HasStatus('DIFFICULT_TERRAIN_WEB') | HasStatus('MAG_RAMPART_AURA_DIFFICULT_TERRAIN') | HasStatus('DIFFICULT_TERRAIN_LAVA')
end

function HasDashStatus(entity)
    entity = entity or context.Source
	return HasStatus('DASH', entity ) | HasStatus('DASH_STACKED', entity ) | HasStatus('DASH_STACKED_2', entity )
end

function StrideCostSpellCheck()
	return SpellCategoryIs(SpellCategory.Dash) | HasUseCosts('Movement') | HasUseCosts('Stride')
end

function HasteSpellCheck()
	return ( ExtraAttackSpellCheck() | SpellCategoryIs(SpellCategory.Dash) | HasUseCosts('Movement',false) | HasUseCosts('Stride',false) ) & HasUseCosts('ActionPoint',true)
end

--Chance of a crit on an opportunity attack
function OpportunityAttackCritRoll(source,source_pos,observer,observer_pos)
	
	local attacktype = AttackType.MeleeUnarmedAttack
	
	if WieldingWeapon('Melee', false, true, context.Observer) and not HasStatus('DISARMED',OBSERVER_OBSERVER).Result then
		attacktype = AttackType.MeleeWeaponAttack
	end
	
	local attack = Attack(attacktype,false,false,source,source_pos,observer,observer_pos)

	--Crit chance can be more than success-50%, with Advantage or an exceedingly high bonus.
	local crit_chance = attack.Chance - 0.5
	local crit_flat_dc = math.floor( 21 - crit_chance*20 )
	
    return ConditionResult(true,{},{},1.0) --RollDieAgainstDC(DiceType.d20,crit_flat_dc)
end

function OpportunityAttackNonCritRoll()
	--Used in a SpellRoll, so the attack field can be simpler.
	local attacktype = AttackType.MeleeUnarmedAttack
	
	if WieldingWeapon('Melee', false, true, context.Source) and not HasStatus('DISARMED').Result then
		attacktype = AttackType.MeleeWeaponAttack
	end
	
	local attack = Attack(AttackType.MeleeWeaponAttack)
	
	--Note: Crit chance can be more than success-50%, with Advantage or an exceedingly high bonus.
	local crit_chance = math.max(attack.Chance - 0.5, 0.05)
	local success_chance = attack.Chance - crit_chance
	local fail_chance = 1 - attack.Chance
	local non_crit_percentile_dc = math.floor( 100*fail_chance/(success_chance + fail_chance) + 1 )
	
	local roll = RollDieAgainstDC(DiceType.d100,non_crit_percentile_dc)
	local roll_chance = success_chance/(success_chance + fail_chance)
	
	return ConditionResult(roll.Result,{},{},roll_chance)
end


function OpportunityAttackCheck()
	local isMove = SpellCategoryIs(SpellCategory.Dash) | SpellCategoryIs(SpellCategory.Jump) | SpellTypeIs(SpellType.Rush)
	local canHitMove = (~Player(context.Source) & Tagged('AI_IGNORED_TARGET') & ~HasStatus('GNOLL_SUDDENRUSH')) & ~HasStatus('SHOCKWAVE') & ~(HasStatus('MOBILE_NO_AOO', context.Source) & HasStatus('MOBILE_NO_AOO_SOURCE', context.Target)) & ~HasStatus('FLAMING_SPHERE_AURA') & ~HasStatus('SNEAKING',context.Target) & ~HasStatus('SG_Ignore_AOO',context.Target)
	
	return (~HasStatus('SANCTUARY',context.Source) & ~HasSpellFlag(SpellFlags.IgnoreAoO, context.Target)) & ( IsSpell() | (isMove & canHitMove) | IsRangedAttack() | HasSpellFlag(SpellFlags.HasSomaticComponent, context.Target) )
end

--Deprecated movement functions

function IsAnyActionStatusEvent()
	return IsStatusEvent(StatusEvent.OnAttack) | IsStatusEvent(StatusEvent.OnSpellCast)
end

function HasMindSanctuary(entity)
    entity = entity or context.Source
	return HasStatus('MF_MIND_SANCTUARY', entity) | HasStatus('TAD_MIND_SANCTUARY', entity) | HasPassive('TAD_MindSanctuary', entity)
end

function DashClearsMove(entity)
    entity = entity or context.Source
	return ~HasActionResource('Movement', 1 , 0, false, false, entity) | (~HasMindSanctuary(entity) & ~HasDashStatus(entity) & ~HasStatus('AUTO_STRIDE_MOVE',entity))
end

--Helps the AI remember it has movement
function DontClearAIMove()
	return ~Player() & HasActionResource('Movement', 100 , 0, true, false)
end

--Level scaling
function TrainedWeapon() --Proficient
	return IsProficientWith(context.Source, GetAttackWeapon(context.Source))
end

function TrainedArmor() --Proficient or unarmored
	if ~WearingArmor(context.Source) then
		return ConditionResult(true)
	end

	--Armor test from Community Library
	local armor = GetActiveArmor(context.Source)
	
    local hasLightArmor = armor.ArmorType == ArmorType.Padded 
    | armor.ArmorType == ArmorType.Leather 
    | armor.ArmorType == ArmorType.StuddedLeather
	
	local hasMediumArmor = armor.ArmorType == ArmorType.Hide 
    | armor.ArmorType == ArmorType.ChainShirt 
    | armor.ArmorType == ArmorType.ScaleMail 
    | armor.ArmorType == ArmorType.BreastPlate
    | armor.ArmorType == ArmorType.HalfPlate 

	return HasProficiency('HeavyArmor',context.Source) or (HasProficiency('LightArmor',context.Source) & hasLightArmor) or (HasProficiency('MediumArmor',context.Source) & hasMediumArmor)
end

function TrainedSkill() --Proficient
	return HasProficiencyBonus(context.CheckedAbility,context.CheckedSkill,context.Source)
end

-- Off-guard

function OffGuard(target,source)
    target = target or context.Target
    source = source or context.Source
	
	local feint = IsMeleeAttack() & (HasStatus('FEINT_ROUND',target,source) or HasStatus('FEINT_ONCE',target,source))
	local hidden = HasStatus('SG_Invisible',source) or HasStatus('SNEAKING',source)
	--You aren't off-guard to hidden, undetected, or flanking creatures of your level or lower
	local denyadvantage = Tagged('ROGUE_DENYADVANTAGE',target) & (target.Level >= source.Level)
	local dreadstriker = Tagged('ROGUE_DREADSTRIKER',source) & HasStatus('SG_Frightened',target)
	
	return Tagged('OFF_GUARD',target) | feint | dreadstriker --hidden & ~denyadvantage | dreadstriker
end

function Flanking(exclusionStatus, distance, tag, hasShield, target, source)
	distance = distance or 1.5
    target = target or context.Target
    source = source or context.Source

    local errorTrue = {ConditionError("HasAllyWithinRange", {ConditionErrorData.MakeFromNumber(distance, EErrorDataType.Distance)})}
    local errorFalse = {ConditionError("HasNotAllyWithinRange", {ConditionErrorData.MakeFromNumber(distance, EErrorDataType.Distance)})}

    local allies = GetAlliesWithinRange(distance, target, source)
    if allies ~= nil then
        for _, entity in ipairs(allies.Allies) do
			
            -- ensure entity does not have the excluded status
            local noExcludedStatus = ConditionResult(exclusionStatus == nil)
            if exclusionStatus then
                noExcludedStatus = ~HasStatus(exclusionStatus, entity)
            end

            -- filter by tag if provided
            local hasTag = ConditionResult(tag == nil)
            if tag then
                hasTag = Tagged(tag, entity)
            end

            -- filter by having a shield if requested
            local shieldEquipped = ConditionResult(not hasShield)
            if hasShield then
                shieldEquipped = HasShieldEquipped(entity)
            end

			-- need to be looking at an ally, and that ally must be looking at you and the enemy
			local flankingAngles = ConditionResult(false)
			if FacingMe(entity,source).Result then
				flankingAngles = ConditionResult(true)
			end

            if noExcludedStatus.Result and hasTag.Result and shieldEquipped.Result and flankingAngles.Result then
                return ConditionResult(true, errorFalse, errorTrue)
            end
        end
    end

    return ConditionResult(false, errorFalse, errorTrue)
end

-- Status MAP_X_ATTACKS

--~functional for Stats.
function CalculateMAP()
	local MAP = -5
	if AgileMAP() then
		MAP = -4
	end
	return MAP
end

function AgileMAP()
	return HasWeaponProperty(WeaponProperties.Light, context.AttackWeapon) or IsMeleeUnarmedAttack()
end

-- Interrupt CritThreshold

function CritThresholdSuccess()
    local notCrit = context.InterruptedRoll.NaturalRoll < 20 & context.InterruptedRoll.NaturalRoll > 1
	local critDC = context.InterruptedRoll.Difficulty + 10
    local exceededBy10 = context.InterruptedRoll.Total >= critDC

    return ConditionResult(notCrit & exceededBy10)
end

function CritThresholdFail()
    local notCrit = context.InterruptedRoll.NaturalRoll < 20 & context.InterruptedRoll.NaturalRoll > 1
	local critTotal = context.InterruptedRoll.Total + 10
    local failedBy10 = critTotal <= context.InterruptedRoll.Difficulty

    return ConditionResult(notCrit & failedBy10)
end

-- Weapons

function WeaponDieSizeNum(num)
    --local weaponEntity = GetActiveWeapon(entity, true)
	--if IsWeaponOfProficiencyGroup('Clubs|Quarterstaffs',weaponEntity) then
	--end
	--GetModifier(context.Source.WeaponAttackRollAbility)
	--DealDamage(MainMeleeWeapon, MainMeleeWeaponDamageType)
    return ConditionResult(true)
end

--Barbarian

function RageSpell()
	return SpellId('Shout_Rage') | SpellId('Shout_AnimalRage') | SpellId('Shout_FuryRage') | SpellId('Shout_BludgeoningDragonRage') | SpellId('Shout_PoisonDragonRage') | SpellId('Shout_FifeDragonRage') | SpellId('Shout_ForceDragonRage') | SpellId('Shout_PsychicDragonRage') | SpellId('Shout_GiantRage') | SpellId('Shout_Rage_Frenzy') | SpellId('Shout_Rage_Totem_Bear') | SpellId('Shout_Rage_Boar')
end

--Fighter

function ExactingStrikeFX()
    return (SpellId('Target_ExactingStrike') or SpellId('Projectile_ExactingStrike')) & HasStatus('MAP_2_ATTACKS',SELF)
end

--Ranger

function HuntedPrey(target,source)
	source = source or context.Source
	target = target or context.Target
	return HasStatus('HUNT_PREY',target,source)
end

function CanCommandMinion(entity)
	entity = entity or context.Source
	-- Must be able to take actions.
	local hasActions = HasActionResource('ActionPoint', 1 , 0, false, false)
	-- Must be able to speak or use telepathy (as a mind flayer).
	local canConcentrate = Tagged('MINDFLAYER',entity) | HasPassive('TAD_PartialCeremorph',entity) | ~( HasVerbalComponentBlocked() | HasSpellCastBlocked() )
	-- Cannot be incapacitated.
	local blockedStatusGroups = HasStatus('SG_Incapacitated',entity) | HasStatus('SG_Prone',entity) | HasStatus('SG_Stunned',entity) | HasStatus('SG_Dominated',entity) | HasStatus('SG_Paralyzed',entity) |  HasStatus('SG_Unconscious',entity)
	local blockedStatuses = HasStatus('STINKING_CLOUD',entity) | HasStatus('INCAPACITATED_DND',entity) | HasStatus('COMMAND_APPROACH') | HasStatus('COMMAND_FLEE',entity) | HasStatus('CROWNOFKARSUS_UNCONCIOUS',entity) | HasStatus('LURING_SONG',entity) | HasStatus('IRRESISTIBLE_DANCE') | HasStatus('LOW_OSKARSBELOVED_UNNERVED',entity) | HasStatus('MIND_MASTERY',entity) | HasStatus('END_KARSUSCOMPULSION_CHANNEL',entity)
	
	return hasActions & canConcentrate & ~Dead(entity) & ~blockedStatusGroups & ~blockedStatuses
end

--Rogue

function CanPrecisionDamage(target)
    target = target or context.Target
    return ~(Tagged('OOZE',target)|Tagged('SHADOW',target)|Tagged('GHOST',target)|Tagged('DISPLACER_BEAST',target)|Tagged('SCRYING_EYE',target)|HasPassive('Ethereal',target))
end

function SneakAttackWeapon(entity, weapon)
	entity = entity or context.Source
	weapon = context.AttackWeapon
	
	-- Agile, finesse, or ranged
	local standard_weapon = HasWeaponProperty(WeaponProperties.Light, weapon) | HasWeaponProperty(WeaponProperties.Finesse, weapon) | HasWeaponProperty(WeaponProperties.Ammunition, weapon)
	
	local thrown_weapon = IsUnarmedAttack() & SpellTypeIs(SpellType.Throw) & ( HasWeaponProperty(WeaponProperties.Light, context.HitDescription.ThrownObject) |HasWeaponProperty(WeaponProperties.Finesse, context.HitDescription.ThrownObject) )
	
	-- maximum: d8 simple, d6 martial (one-handed versatiles)
	local is_ruffian = HasPassive('Ruffian',entity)
	local onehand_check = WieldingWeapon('Melee', true, false, entity) | HasShieldEquipped(entity)
	local ruffian_weapon = IsWeaponOfProficiencyGroup('SimpleWeapons', weapon) | IsWeaponOfProficiencyGroup('Morningstars', weapon) | ( onehand_check & IsWeaponOfProficiencyGroup('Tridents', weapon) )
	
	return IsMeleeUnarmedAttack() | standard_weapon | thrown_weapon | (is_ruffian & ruffian_weapon)
end

function WieldingSneakAttackWeapon(entity)
    entity = entity or context.Target
    local weaponEntity = GetActiveWeapon(entity, true)
	
	-- Agile or finesse
	local standard_weapon = WieldingWeapon('Finesse', false, true, entity) | WieldingWeapon('Light', false, true, entity)
	
	-- maximum: d8 simple, d6 martial (one-handed versatiles)
	local is_ruffian = HasPassive('Ruffian',entity)
	local onehand_check = WieldingWeapon('Melee', true, false, entity) | HasShieldEquipped(entity)
	local ruffian_weapon = IsWeaponOfProficiencyGroup('SimpleWeapons', weaponEntity) | IsWeaponOfProficiencyGroup('Morningstars', weaponEntity) | ( onehand_check & IsWeaponOfProficiencyGroup('Tridents', weaponEntity) )
	
	return standard_weapon | (is_ruffian & ruffian_weapon)
end